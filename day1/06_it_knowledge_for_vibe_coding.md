# 6. 바이브 코딩을 위한 IT 지식 배우기

## 왜 IT 기본 지식이 중요한가?
- 바이브 코딩은 AI가 많은 것을 해주지만, AI에게 정확한 요구를 하고 결과를 이해하려면 최소한의 IT 지식이 필수적입니다.
- 생성된 코드가 어떤 원리로 동작하는지 알아야 수정하고 조합할 수 있습니다.

## 핵심 IT 개념
### 1. HTTP (HyperText Transfer Protocol)
HTTP는 웹에서 클라이언트(주로 웹 브라우저)와 서버가 데이터를 주고받기 위해 사용하는 핵심적인 규칙(프로토콜)입니다. 이름에서 알 수 있듯이, HTTP는 본래 하이퍼텍스트(Hypertext) 문서를 전송하기 위해 고안되었습니다.

하이퍼텍스트(Hypertext)란 무엇일까요?

하이퍼텍스트는 단순히 순차적으로만 읽는 텍스트(Text)를 넘어선 개념입니다. 문서 내의 특정 단어나 구절에 **링크(Link)** 를 부여하여, 사용자가 그 링크를 클릭하면 관련된 다른 문서나 데이터로 즉시 이동할 수 있는 비선형적(non-linear) 구조의 텍스트를 의미합니다. 우리가 흔히 웹 페이지에서 밑줄 친 파란색 글씨를 클릭해 다른 페이지로 넘어가는 경험이 바로 하이퍼텍스트의 가장 대표적인 예입니다.

월드 와이드 웹(WWW)의 창시자인 팀 버너스리(Tim Berners-Lee)는 이 '하이퍼텍스트'라는 개념을 통해 정보들이 거미줄처럼 서로 연결된 거대한 정보 공간을 구상했습니다. 그리고 바로 이 하이퍼텍스트 문서들을 웹상에서 원활하게 주고받을 수 있도록 만든 통신 규약이 바로 **하이퍼텍스트 전송 프로토콜(HTTP)** 인 것입니다.

따라서 HTTP라는 이름에는 '단순 텍스트뿐만 아니라, 다른 문서로 연결되는 링크를 포함한 하이퍼텍스트를 전송하는 것이 핵심 목적'이라는 의미가 담겨 있습니다. 오늘날에는 이미지, 영상, JSON, XML 등 다양한 형태의 데이터를 전송하지만, 그 시작은 하이퍼텍스트였습니다. 

<details>
<summary><b>HTTP에 대해 더 알아보기</b></summary>

# HTTP란 무엇일까?

수많은 정보가 오가는 곳에는 항상 효율적인 소통을 위한 약속이 필요합니다. 예를 들어 주식 시장에서 거래하려면 이름, 계좌, 날짜, 금액 등 정해진 양식에 맞춰야 하죠. 이러한 규칙이 있어야만 구매자와 판매자 모두 원활하게 거래를 마칠 수 있습니다.
![](https://velog.velcdn.com/images%2Fdoomchit_3%2Fpost%2Fff741055-7c6a-4a47-9333-500be49a31fc%2Fhttp2-http.jpg)

> **HTTP(Hyper Text Transfer Protocol)** 는 웹 문서를 만드는 언어인 HTML 파일을 서로 주고받기 위해 사용되는 통신 규약입니다. 이 통신은 TCP와 UDP를 기반으로 이루어지며, 일반적으로 80번 포트를 사용합니다.

※ **통신 프로토콜(통신 규약)**: 컴퓨터나 통신 장비 사이에서 메시지를 주고받을 때 따르는 양식과 규칙 체계를 말합니다. 여기에는 신호 체계, 인증, 오류 감지 같은 기능이 포함될 수 있으며, 물리적 측면(매체, 단자 규격 등)과 논리적 측면(데이터 형식, 전송 절차 등)으로 구성됩니다.

# HTTP의 주요 특징

  - HTTP 메시지는 **서버와 클라이언트 양측에서 해석**됩니다.
  - TCP/IP를 기반으로 동작하는 **응용 프로토콜(Application Protocol)** 입니다.
  - HTTP는 연결 상태를 기억하지 않는 **비연결성(Stateless) 프로토콜**입니다. 즉, 클라이언트의 이전 요청을 서버가 기억하지 않습니다.
  - 이러한 비연결성의 한계를 극복하기 위해 **쿠키(Cookie)와 세션(Session)** 기술이 사용됩니다.
  - 비연결성 프로토콜의 특성상, 통신은 **요청(Request)과 응답(Response) 방식**으로만 이루어집니다.
  - 클라이언트는 **도메인과 자원 경로(URL)** 또는 \*\*식별자(URI)\*\*를 통해 서버에 무언가를 요청하고, 서버는 그에 맞는 **HTML 문서 등으로 응답**합니다.
  - HTTP 통신은 HTML 문서에만 국한되지 않습니다. 단순 텍스트(Plain text)부터 JSON, XML 같은 다양한 형태의 데이터도 주고받을 수 있으며, 보통 클라이언트가 받고자 하는 데이터 형태를 명시해서 요청합니다.
  - 인터넷 프로토콜 계층에서 HTTP는 최상위인 **응용 계층**에 속합니다.
      - **응용 계층 (DNS, FTP, HTTP)**
      - 전송 계층 (TCP, UDP, SCTP)
      - 네트워크 계층 (IP, ARP, RARP)
      - 링크 계층 (이더넷, WIFI, 토큰링)

# HTTP 통신 과정 (요청과 응답)

> ① 클라이언트(사용자)가 서버로 **HTTP Request(요청)** 를 보냅니다.   
> ② 서버는 그 요청을 받아 처리한 뒤 **HTTP Response(응답)** 를 반환합니다.

***이러한 통신 메시지는 브라우저 개발자 도구(`F12`)의 `Network` 탭에서 직접 확인할 수 있습니다.***

## 1\) HTTP Request (요청) 메시지

`요청`이란 웹 브라우저의 **URL**을 통해 특정 **웹사이트(도메인)** 의 어떤 페이지를 달라고 알리는 행위입니다. 요청 메시지의 구조는 다음과 같습니다.

```
Request-Line
*(( general-header | request-header | entity-header ) CRLF)
CRLF
[ message-body ]
```

### ① Request-Line (요청의 첫 줄)

요청의 목적지(URL), 요청 방식(Method), HTTP 버전 정보가 담기는 첫 번째 줄입니다. 아래 그림의 Request URL, Request Method가 여기에 해당합니다.

### ② Header (헤더)

요청을 보내는 클라이언트의 PC나 브라우저 종류, 사용 언어, 쿠키 등 다양한 부가 정보가 담깁니다. 이 때문에 헤더 영역의 데이터는 보안에 민감할 수 있습니다.

### ③ CRLF

헤더와 본문을 구분하는 역할을 하는 줄바꿈(Carriage Return Line Feed) 명령입니다.

### ④ Message-body (본문)

주로 클라이언트가 서버로 전달할 실제 데이터가 담기는 영역입니다. 예를 들어 로그인 폼에 입력한 아이디, 비밀번호 등의 데이터가 보안을 위해 이 영역에 담겨 서버로 전송됩니다.

## 2\) HTTP Response (응답) 메시지

`응답`이란 `요청`에 대해 웹 서버가 클라이언트에게 처리 결과와 데이터를 보내주는 것을 의미합니다.

```
Status-Line
*(( general-header | response-header | entity-header ) CRLF)
CRLF
[ message-body ]
```

### ① Status-Line (상태 표시줄)

응답의 상태를 알려주는 첫 줄로, HTTP 버전과 함께 **상태 코드(Status Code)** 라는 세 자리 숫자로 요청의 성공 여부나 처리 상태를 나타냅니다.

### ② Header (헤더)

요청 헤더와 마찬가지로, 응답에서도 서버의 종류나 웹사이트 관련 환경 정보 등 다양한 부가 정보가 헤더에 담겨 제공됩니다.

### ③ Message-body (본문)

서버가 사용자에게 실제로 전달하는 내용, 즉 웹 페이지를 구성하는 HTML 소스 코드나 데이터가 담기는 영역입니다.

## HTTP Method (요청의 종류)

`Method`는 클라이언트가 서버에게 요청의 목적이 무엇인지를 알리는 수단입니다.

  - **GET**: 데이터를 **조회**할 때 사용 (예: 게시물 목록 보기)
  - **POST**: 새로운 데이터를 **생성/전송**할 때 사용 (예: 회원가입, 글쓰기)
  - **PUT**: 데이터 **전체를 수정**할 때 사용 (예: 회원 정보 전체 업데이트)
  - **DELETE**: 데이터를 **삭제**할 때 사용 (예: 게시물 삭제)
  - **PATCH**: 데이터의 **일부만 수정**할 때 사용 (예: 닉네임만 변경)
  - **OPTIONS**: 해당 URL에서 지원하는 메서드의 종류를 확인할 때 사용

## HTTP Status Code (응답 상태 코드)

`상태 코드`는 서버가 클라이언트에게 요청 처리 결과를 알려주는 세 자리 숫자 약속이며, 크게 다섯 가지 부류로 나뉩니다.

  - **1xx (Informational)**: 요청을 받았으며, 처리 중임을 알림
  - **2xx (Success)**: 요청이 성공적으로 처리되었음을 알림
  - **3xx (Redirection)**: 요청을 완료하려면 추가적인 조치가 필요함을 알림
  - **4xx (Client Error)**: 클라이언트의 요청에 오류가 있음을 알림
  - **5xx (Server Error)**: 서버 측의 문제로 요청을 처리하지 못했음을 알림

### ① 1xx: Informational (정보)

요청이 서버에 성공적으로 도달했고, 현재 처리 중이라는 임시 정보를 나타냅니다. 현재는 거의 사용되지 않습니다.

### ② 2xx: Success (성공)

클라이언트의 요청이 서버에서 성공적으로 수신, 처리되었음을 의미합니다.

### ③ 3xx: Redirection (리디렉션)

요청한 리소스의 위치가 바뀌었으니 다른 주소로 다시 시도하라는 의미입니다. 브라우저는 이 코드를 받으면 자동으로 새 주소로 이동하기 때문에 사용자는 거의 인지하지 못합니다.

### ④ 4xx: Client Error (클라이언트 오류)

클라이언트가 잘못된 요청을 보내 서버가 처리할 수 없는 경우 발생합니다. (예: 존재하지 않는 페이지 요청 - 404 Not Found)

### ⑤ 5xx: Server Error (서버 오류)

클라이언트의 요청은 정상이지만, 서버 내부의 문제로 인해 요청을 처리하지 못했을 때 발생합니다.

## HTTP Header (헤더의 종류)

### ① General Header (공통 헤더)

요청과 응답 양쪽에 모두 포함될 수 있는 헤더입니다. (예: `Date` - 메시지 생성 시간)

### ② Request Header (요청 헤더)

요청하는 클라이언트에 대한 상세 정보(브라우저 종류, 운영체제 등)를 포함합니다. (예: `User-Agent`, `Cookie`)

### ③ Response Header (응답 헤더)

응답을 보내는 서버에 대한 정보나 부가적인 내용을 포함합니다. (예: `Server`, `Allow`)

### ④ Entity Header (엔티티 헤더)

전송되는 데이터(본문) 자체에 대한 정보(데이터 종류, 길이 등)를 포함합니다. (예: `Content-Type`, `Content-Length`)

## HTTP Content-Type

헤더에 포함되는 속성 중 하나로, 전송되는 데이터가 어떤 종류의 미디어 타입인지를 명시합니다.

  - **Application/x-www-form-urlencoded**: 일반적인 HTML 폼 데이터
  - **Application/json**: JSON 형식의 데이터
  - **multipart/form-data**: 이미지나 파일 같은 여러 종류의 데이터를 함께 보낼 때 사용
  - **text/**\*: HTML, CSS, JavaScript 같은 텍스트 기반 파일

## HTTP 버전의 역사

### 0.9 (1990년대 초)

  - 팀 버너스리에 의해 개발됨
  - 요청은 `GET` 메서드 하나만 가능한 단일 라인이었음
  - HTML 파일만 전송할 수 있었음

### 1.0 (1996년)

  - 요청에 `HTTP/1.0`과 같이 버전 정보가 포함되기 시작함
  - 요청의 성공/실패 여부를 상태 코드로 알 수 있게 됨
  - 헤더가 도입되어 다양한 종류의 문서를 전송할 수 있게 됨

### 1.1 (1999년)

  - 오랫동안 웹 표준으로 자리 잡아 현재도 널리 사용됨
  - \*\*파이프라이닝(Pipelining)\*\*을 통해 하나의 요청이 완료되기 전에 다음 요청을 보낼 수 있게 되어 효율이 높아짐
  - 캐시 제어 기능이 도입됨
  - 이전 버전의 불명확한 부분들을 개선함

### 2.0 (2015년)

  - 구글의 SPDY 프로토콜을 기반으로 표준화됨
  - 기존의 텍스트 기반 프로토콜이 **이진(Binary) 프로토콜**로 변경되어 파싱 속도가 빨라짐
  - 하나의 연결로 여러 요청을 동시에 처리하는 \*\*멀티플렉싱(Multiplexing)\*\*이 가능해짐
  - 중복되는 헤더 정보를 압축하여 전송 효율을 높임
  - 서버가 클라이언트에게 필요할 것 같은 리소스를 미리 보내주는 **서버 푸시(Server Push)** 기능이 도입됨
  - TLS 기반으로 보안이 강화됨

# 참고 자료 📚

[위키피디아](https://ko.wikipedia.org/wiki/HTTP)   
[토마의 개발노트 - http 특징](https://toma0912.tistory.com/69)   
[seunghyun90](https://seunghyun90.tistory.com/41)   
[jinbroing](https://jinbroing.tistory.com/63)   
[모든상태코드](https://ko.wikipedia.org/wiki/HTTP_%EC%83%81%ED%83%9C_%EC%BD%94%EB%93%9C)   

</details>

### 2. API (Application Programming Interface)
- 프로그램들이 서로 소통하기 위한 창구(interface)입니다.
- 날씨 앱이 날씨 정보 회사의 서버에 있는 날씨 데이터를 가져올 때, 날씨 API를 사용합니다.
- API 문서를 읽고 요청하는 방법을 알아야 외부 서비스를 활용할 수 있습니다.

<details>
<summary><b>API에 대해 더 알아보기</b></summary>

# API란 무엇인가?

API(Application Programming Interface)는 서로 다른 소프트웨어 시스템이 대화하고 데이터를 교환할 수 있게 해주는 중간 매개체입니다. 마치 레스토랑에서 주문을 받는 웨이터와 같은 역할을 한다고 생각하면 쉽습니다. 고객(클라이언트)이 메뉴(API 문서)를 보고 음식(데이터)을 주문하면, 웨이터(API)가 주방(서버)에 전달하고 완성된 요리를 다시 가져다주는 것과 같은 원리입니다.

현대 디지털 세계에서 API는 모바일 앱, 웹 애플리케이션, IoT 기기 등 거의 모든 곳에서 사용됩니다. 소셜 미디어 로그인, 날씨 정보 확인, 온라인 결제 처리 등 우리가 일상적으로 사용하는 대부분의 디지털 서비스가 API를 통해 작동합니다.

### REST API의 핵심 개념

REST(Representational State Transfer)는 웹 API를 설계하는 가장 널리 사용되는 아키텍처 스타일입니다. 2000년 Roy Fielding이 처음 소개한 이후로, 단순성과 유연성 덕분에 업계 표준으로 자리잡았습니다.

REST API는 다음과 같은 핵심 원칙을 따릅니다:

**무상태성(Stateless)**: 각 요청은 독립적이며, 서버는 이전 요청 정보를 저장하지 않습니다. 모든 필요한 정보는 요청에 포함되어야 합니다.

**클라이언트-서버 분리**: 사용자 인터페이스와 데이터 저장소가 명확히 분리되어, 각각 독립적으로 발전할 수 있습니다.

**균일한 인터페이스**: 모든 리소스는 고유한 URL로 식별되며, 표준화된 HTTP 메서드를 사용하여 일관된 방식으로 접근합니다.

**캐시 가능성**: 응답을 캐시할 수 있어 성능이 향상되고 서버 부하가 감소합니다.

### HTTP 메서드와 CRUD 작업

REST API는 기본적인 데이터 조작을 위해 HTTP 메서드를 활용합니다:

- **GET**: 데이터 조회 (Read)
- **POST**: 새로운 데이터 생성 (Create)  
- **PUT**: 기존 데이터 전체 수정 (Update)
- **DELETE**: 데이터 삭제 (Delete)
- **PATCH**: 데이터 부분 수정

예를 들어, 블로그 API에서 `/api/posts` 엔드포인트는 GET 요청으로 모든 게시글을 조회하고, POST 요청으로 새 게시글을 작성할 수 있습니다.

### API 사용 방법: 단계별 가이드

**1. API 선택과 문서 확인**
먼저 사용할 API를 선택하고 해당 문서를 꼼꼼히 읽어야 합니다. 문서에는 사용 가능한 엔드포인트, 필요한 파라미터, 응답 형식 등이 명시되어 있습니다.

**2. API 키 획득**
대부분의 공개 API는 인증을 위해 API 키를 요구합니다. 이는 비밀번호와 같은 역할을 하며, 무단 사용을 방지합니다.

**3. 요청 구성**
적절한 HTTP 메서드를 선택하고, 필요한 헤더와 파라미터를 설정합니다. 예를 들어:
- 엔드포인트 URL 지정
- HTTP 헤더에 인증 정보 포함
- 요청 본문에 데이터 추가 (POST, PUT의 경우)

**4. 응답 처리**
서버는 상태 코드와 함께 응답을 반환합니다:
- 2xx: 성공
- 4xx: 클라이언트 오류
- 5xx: 서버 오류

응답 데이터는 주로 JSON 형식으로 제공되며, 파싱하여 애플리케이션에서 활용할 수 있습니다.

### 실제 구현 예시

Node.js와 Express를 사용한 간단한 REST API 구현 예시를 살펴보겠습니다:

```javascript
// 기본 서버 설정
const express = require('express');
const app = express();

// 게시글 목록 조회
app.get('/api/posts', (req, res) => {
    // 데이터베이스에서 게시글 조회
    res.json(posts);
});

// 새 게시글 작성
app.post('/api/posts', (req, res) => {
    // 새 게시글 생성 로직
    res.status(201).json(newPost);
});

// 서버 시작
app.listen(3000);
```

### API 설계 방법

**명확한 리소스 구조**: URL은 리소스를 명확하게 표현해야 합니다. `/users/123/posts`처럼 계층 구조를 활용하세요.

**적절한 상태 코드 사용**: 클라이언트가 결과를 이해할 수 있도록 정확한 HTTP 상태 코드를 반환하세요.

**버전 관리**: API가 발전하면서 하위 호환성을 유지하기 위해 버전을 관리하세요 (예: `/api/v1/users`).

**포괄적인 문서화**: 개발자들이 쉽게 이해하고 사용할 수 있도록 상세한 문서를 제공하세요.

**보안 고려사항**: HTTPS 사용, 적절한 인증/인가 메커니즘 구현, 요청 제한 설정 등을 통해 API를 보호하세요.

### API 테스트와 디버깅

Postman, Insomnia 같은 도구를 사용하면 API를 쉽게 테스트할 수 있습니다. 이러한 도구들은:
- 다양한 HTTP 메서드로 요청 전송
- 헤더와 파라미터 설정
- 응답 확인 및 디버깅
- 테스트 자동화

등의 기능을 제공합니다.

### 마무리

API는 현대 소프트웨어 개발의 핵심 구성 요소입니다. REST API의 원칙을 이해하고 적절히 활용하면, 확장 가능하고 유지보수가 쉬운 애플리케이션을 구축할 수 있습니다. 처음에는 복잡해 보일 수 있지만, 기본 개념을 이해하고 실습을 통해 경험을 쌓으면 누구나 효과적으로 API를 설계하고 사용할 수 있습니다.

API 개발은 지속적으로 발전하는 분야이므로, 최신 트렌드를 따라가며 GraphQL, gRPC 같은 새로운 기술도 탐구해보는 것을 추천합니다. 무엇보다 실제 프로젝트를 통해 경험을 쌓는 것이 가장 효과적인 학습 방법입니다.
</details>

### 3. 데이터베이스 (DB)
- 데이터의 집합을 저장하고 관리하는 시스템입니다.
- **SQL DB (관계형):** 엑셀 시트처럼 정해진 테이블(표) 구조에 데이터를 저장 (예: MySQL)
- **NoSQL DB (비관계형):** 더 유연한 구조로 데이터를 저장 (예: JSON 형식)

<details>
<summary><b>데이터베이스에 대해 더 알아보기</b></summary>

데이터베이스(DB)는 여러 사람이 사용하거나 프로그램에서 활용할 목적으로, 관련된 데이터들을 체계적으로 저장하고 관리하는 디지털 저장소입니다. 단순히 데이터를 저장하는 것을 넘어, 효율적이고 안전하게 관리하기 위한 여러 기능을 제공합니다.

**데이터베이스의 종류:**

1.  **관계형 데이터베이스 (RDBMS 또는 SQL DB):**
    - 데이터를 엑셀 시트 같은 '테이블(Table)' 형태로 저장합니다.
    - 각 데이터는 정해진 열(Column)과 행(Row)에 따라 구조화됩니다.
    - 데이터의 일관성과 명확성이 높아 금융, 재고 관리 등 정형화된 데이터에 적합합니다.
    - **예시:** MySQL, PostgreSQL, Oracle

2.  **비관계형 데이터베이스 (NoSQL DB):**
    - 'Not Only SQL'의 약자로, 관계형 모델보다 훨씬 유연한 데이터 모델을 가집니다.
    - **도큐먼트(Document) DB:** JSON과 유사한 문서 형태로 데이터를 저장 (예: MongoDB)
    - **키-값(Key-Value) DB:** 고유한 키에 값을 연결한 단순한 구조로 속도가 빠름 (예: Redis)
    - 대용량의 비정형 데이터 처리에 유리하여 소셜 미디어, IoT 서비스 등에 많이 사용됩니다.

**참고 자료:**
- [Heee's Development Blog - 데이터베이스(DB)란 무엇인가?](https://gmlwjd9405.github.io/2018/10/24/database-what-is-database.html)
- [코딩팩토리 - 데이터베이스란?](https://coding-factory.tistory.com/213)
</details>

### 4. Frontend vs. Backend
- **Frontend:** 사용자가 직접 보는 부분 (웹사이트의 버튼, 이미지, 텍스트 등). (기술: HTML, CSS, JavaScript, React)
- **Backend:** 사용자 눈에 보이지 않는 서버 쪽 로직 (데이터 처리, DB 연동, API 제공 등). (기술: Python, Node.js, Java)
- Streamlit은 이 두 가지를 파이썬만으로 간단하게 다룰 수 있게 해주는 도구입니다.

<details>
<summary><b>Frontend와 Backend에 대해 더 알아보기</b></summary>

웹 서비스를 하나의 레스토랑에 비유할 수 있습니다.

- **프론트엔드 (Frontend):** 레스토랑의 홀과 같습니다. 손님(사용자)이 직접 보고 경험하는 공간으로, 인테리어, 메뉴판, 테이블 배치 등이 여기에 해당합니다. 웹에서는 레이아웃, 버튼, 폰트, 이미지 등 사용자의 눈에 보이는 모든 시각적 요소를 만들고, 사용자의 클릭이나 입력에 반응하도록 구현합니다.
  - **주요 기술:** HTML (구조), CSS (디자인), JavaScript (동작), React/Vue (UI 라이브러리)

- **백엔드 (Backend):** 레스토랑의 주방과 같습니다. 손님 눈에는 보이지 않지만, 실제 요리를 만들고 재료를 관리하는 핵심적인 공간입니다. 웹에서는 서버, 데이터베이스, 비즈니스 로직(회원가입, 로그인, 결제 처리 등)을 다루며, 프론트엔드가 요청하는 데이터를 처리하고 제공하는 역할을 합니다.
  - **주요 기술:** Python, Java, Node.js (프로그래밍 언어), Spring, Django (프레임워크), MySQL, MongoDB (데이터베이스)

프론트엔드와 백엔드는 **API**를 통해 서로 데이터를 주고받으며 협력하여 하나의 완전한 서비스를 만들어냅니다.

**참고 자료:**
- [코드스테이츠 - 프론트엔드와 백엔드의 차이](https.codestates.com/blog/content/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EB%B0%B1%EC%97%94%EB%93%9C-%EC%B0%A8%EC%9D%B4)
- [제로베이스 - 프론트엔드와 백엔드 차이점](https://zero-base.co.kr/category/dev/front-vs-back)
</details>